<!DOCTYPE html>
<html lang="en">
<head>
	<title>three.js webgl</title>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
</head>
<body>

	<div id="container" style="width:1024px;height:768px;"></div>

	<script id="vertexShader" type="x-shader/x-vertex">

		attribute vec2 uv2;
		varying vec2 vUV;
		varying vec2 vUV2;
		uniform vec2 grp_lt;
		uniform float grp_w;
		uniform float grp_h;

		void main()	{
			vUV = uv;
			vUV2 = vec2((uv2.s - grp_lt.x) / grp_w, (uv2.t - grp_lt.y) / grp_h);
			gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
		}

	</script>

	<script id="fragmentShader" type="x-shader/x-fragment">

		varying vec2 vUV;
		varying vec2 vUV2;
		uniform float time;
		uniform sampler2D sMainTex;
		uniform sampler2D sGraphicTex;

		void main()	{
			float ga = texture2D( sGraphicTex, vUV2 ).a;
			gl_FragColor = (1.0 - ga) * texture2D( sMainTex, vUV ) + ga * texture2D( sGraphicTex, vUV2);
		}

	</script>

	<!-- Import maps polyfill -->
	<!-- Remove this when import maps will be widely supported -->
	<script async src="https://unpkg.com/es-module-shims@1.3.6/dist/es-module-shims.js"></script>

	<script type="importmap">
		{
			"imports": {
				"three": "./node_modules/three/build/three.module.js",
				"three/addons/": "./node_modules/three/examples/jsm/"
			}
		}
	</script>

	<script type="module">

		import * as THREE from 'three';
        import { OrbitControls } from './node_modules/three/examples/jsm/controls/OrbitControls.js';

		let camera, scene, renderer;

		let cameraControl;

		let uniforms;

        // init graphics info
        let grp_lt = new THREE.Vector2(0.3, 0.2);
        let grp_w = 0.4;
        let grp_h = 0.72;


		init();
		animate();


        function screenToNormalized(px, py) {

            //rayLog(3, "mouse px : " + px + "," + py);

            var cx = (px / renderer.domElement.clientWidth) * 2.0 - 1.0;
            var cy = (1.0 - py / renderer.domElement.clientHeight) * 2.0 - 1.0;
            //rayLog(3, "normalized (-1,1) coord : " + cx + "," + cy);

            var nc = new THREE.Vector2(cx, cy);
            return nc;
        }


		function init() {

			const container = document.getElementById('container');

			camera = new THREE.PerspectiveCamera(60, 1024.0 / 768.0, 0.1, 100);
            camera.up.set(0, 1, 0);
			//camera.position.set(0, -10, 10);
			//camera.lookAt(0, 0, 0);

			scene = new THREE.Scene();

			const geometry = new THREE.PlaneGeometry(10, 10, 20, 20).rotateX(-Math.PI / 2.0);
			geometry.computeVertexNormals();

			// mesh height tune
			let parr = geometry.attributes.position.array;
			for (let i = 0; i < 20; i++) {
				for (let j = 0; j < 20; j++) {
					parr[((20 * i) + j) * 3 + 1] = Math.random() * 0.25 + (1. - Math.abs(10 - i) * 0.1) + (1. - Math.abs(10 - j) * 0.1);
				}
			}



			// second uv
			//let uvs = geometry.attributes.uv.array;
			//geometry.setAttribute('uv2', new THREE.Float32BufferAttribute(uvs, 2));
			geometry.attributes.uv2 = geometry.attributes.uv.clone();

			const main_tex = new THREE.TextureLoader().load('../../data/checked.jpg');
            const gr_tex = new THREE.TextureLoader().load('../../data/ralph-lauren.png');


			uniforms = {
				//time: { value: 1.0 },
                grp_lt: { value: grp_lt },
                grp_w: { value: grp_w },
                grp_h: { value: grp_h },
				sMainTex: { value: main_tex },
                sGraphicTex: { value: gr_tex },
			};

			const material = new THREE.ShaderMaterial({

				uniforms: uniforms,
				vertexShader: document.getElementById('vertexShader').textContent,
				fragmentShader: document.getElementById('fragmentShader').textContent

			});

			const mesh = new THREE.Mesh(geometry, material);
			scene.add(mesh);

			renderer = new THREE.WebGLRenderer();
			renderer.setSize(1024, 768);
			container.appendChild(renderer.domElement);

			cameraControl = new OrbitControls(camera, renderer.domElement);
			cameraControl.target.set(0, 0, 0);
			cameraControl.update();
			cameraControl.enabled = true;

			camera.position.set(0, 10, 10);
			camera.lookAt(0, 0, 0);

			onWindowResize();

			window.addEventListener('resize', onWindowResize);


			window.addEventListener('keyup', (event) => {

				if (lbDown || grDragStart)
					return;

				if (event.key === '1') {
					console.log("toggle camera control");
					cameraControl.enabled = !cameraControl.enabled;
					container.style.cursor = cameraControl.enabled ? "auto" : "move";
				}
			});



			let lbDown = false;
			let grDragStart = false;
			let grPickUV = new THREE.Vector2(0, 0);
            let grPickOffset = new THREE.Vector2(0, 0);

            const raycaster = new THREE.Raycaster();
			

            container.addEventListener('pointerdown', (event) => {

				if (cameraControl.enabled)
					return;

				if (event.button === 0) {
					if (!lbDown) {

						// pick mesh point
                        let normalizedPosition = screenToNormalized(event.offsetX, event.offsetY);
                        raycaster.setFromCamera(normalizedPosition, camera);
                        let intersectedObjects = raycaster.intersectObject(mesh, true);
                        if (intersectedObjects && intersectedObjects.length > 0) {

                            let pick_mesh = intersectedObjects[0].object;
							if (pick_mesh) {
								grPickUV.set(intersectedObjects[0].uv.x, intersectedObjects[0].uv.y);
								if (grPickUV.x < grp_lt.x || grPickUV.x > (grp_lt.x + grp_w)) {
									console.log("picked out of graphic" + grPickUV.x + "," + grPickUV.y);
								} else {
									grPickOffset = grPickUV.clone().sub(grp_lt);
                                    console.log("picked graphic with offset " + grPickOffset.x + "," + grPickOffset.y);
                                    grDragStart = true;
								}
                            }

                        }

						lbDown = true;
						container.setPointerCapture(event.pointerId);
					}
				}

			});

            container.addEventListener('pointerup', (event) => {

                if (cameraControl.enabled)
                    return;

				if (event.button === 0) {
					if (lbDown) {

						if (grDragStart) {
                            grDragStart = false;
						}

						lbDown = false;
						container.releasePointerCapture(event.pointerId);
					}
                }

            });

            container.addEventListener('pointermove', (event) => {

                if (cameraControl.enabled)
                    return;

				if (lbDown && grDragStart) {

                    // drag move to mesh point
                    let normalizedPosition = screenToNormalized(event.offsetX, event.offsetY);
                    raycaster.setFromCamera(normalizedPosition, camera);
                    let intersectedObjects = raycaster.intersectObject(mesh, true);
                    if (intersectedObjects && intersectedObjects.length > 0) {

                        let pick_mesh = intersectedObjects[0].object;
                        if (pick_mesh) {
                            console.log("move to mesh uv " + intersectedObjects[0].uv.x + "," + intersectedObjects[0].uv.y);
							let moveToUV = intersectedObjects[0].uv.clone();
							grp_lt = moveToUV.clone().sub(grPickOffset);
                        }

                    }


				}

            });



		}

		function onWindowResize() {

			//renderer.setSize(window.innerWidth, window.innerHeight);

		}

		//

		function animate() {

			requestAnimationFrame(animate);

			//uniforms['time'].value = performance.now() / 1000;
            // update grp coordinates
            uniforms['grp_lt'].value.set(grp_lt.x, grp_lt.y);

			renderer.render(scene, camera);

		}

	</script>

</body>
</html>